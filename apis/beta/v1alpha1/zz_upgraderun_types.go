/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type EdgeGroupObservation struct {

	// Flag to indicate whether upgrade of this group is enabled or not
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// ID of upgrade unit group
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Upgrade method to specify whether the upgrade is to be performed in parallel or serially
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
	PauseAfterEachUpgradeUnit *bool `json:"pauseAfterEachUpgradeUnit,omitempty" tf:"pause_after_each_upgrade_unit,omitempty"`
}

type EdgeGroupParameters struct {

	// Flag to indicate whether upgrade of this group is enabled or not
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// ID of upgrade unit group
	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`

	// Upgrade method to specify whether the upgrade is to be performed in parallel or serially
	// +kubebuilder:validation:Optional
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
	// +kubebuilder:validation:Optional
	PauseAfterEachUpgradeUnit *bool `json:"pauseAfterEachUpgradeUnit,omitempty" tf:"pause_after_each_upgrade_unit,omitempty"`
}

type EdgeUpgradeSettingObservation struct {

	// Whether run upgrade parallel
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Whether run post upgrade check
	PostUpgradeCheck *bool `json:"postUpgradeCheck,omitempty" tf:"post_upgrade_check,omitempty"`
}

type EdgeUpgradeSettingParameters struct {

	// Whether run upgrade parallel
	// +kubebuilder:validation:Optional
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Whether run post upgrade check
	// +kubebuilder:validation:Optional
	PostUpgradeCheck *bool `json:"postUpgradeCheck,omitempty" tf:"post_upgrade_check,omitempty"`
}

type FinalizeUpgradeSettingObservation struct {

	// Finalize upgrade when complete
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type FinalizeUpgradeSettingParameters struct {

	// Finalize upgrade when complete
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type GroupStateObservation struct {
	GroupID *string `json:"groupId,omitempty" tf:"group_id,omitempty"`

	GroupName *string `json:"groupName,omitempty" tf:"group_name,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type GroupStateParameters struct {
}

type HostGroupObservation struct {

	// Name of upgrade unit group
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Flag to indicate whether upgrade of this group is enabled or not
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Hosts to be included in the upgrade group
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// ID of upgrade unit group
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Maintenance mode config evacuate powered off vms
	MaintenanceModeConfigEvacuatePoweredOffVms *bool `json:"maintenanceModeConfigEvacuatePoweredOffVms,omitempty" tf:"maintenance_mode_config_evacuate_powered_off_vms,omitempty"`

	// Maintenance mode config vsan mode
	MaintenanceModeConfigVsanMode *string `json:"maintenanceModeConfigVsanMode,omitempty" tf:"maintenance_mode_config_vsan_mode,omitempty"`

	// Upgrade method to specify whether the upgrade is to be performed in parallel or serially
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
	PauseAfterEachUpgradeUnit *bool `json:"pauseAfterEachUpgradeUnit,omitempty" tf:"pause_after_each_upgrade_unit,omitempty"`

	// Rebootless upgrade
	RebootlessUpgrade *bool `json:"rebootlessUpgrade,omitempty" tf:"rebootless_upgrade,omitempty"`

	// Upgrade mode
	UpgradeMode *string `json:"upgradeMode,omitempty" tf:"upgrade_mode,omitempty"`
}

type HostGroupParameters struct {

	// Name of upgrade unit group
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Flag to indicate whether upgrade of this group is enabled or not
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Hosts to be included in the upgrade group
	// +kubebuilder:validation:Optional
	Hosts []*string `json:"hosts,omitempty" tf:"hosts,omitempty"`

	// ID of upgrade unit group
	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Maintenance mode config evacuate powered off vms
	// +kubebuilder:validation:Optional
	MaintenanceModeConfigEvacuatePoweredOffVms *bool `json:"maintenanceModeConfigEvacuatePoweredOffVms,omitempty" tf:"maintenance_mode_config_evacuate_powered_off_vms,omitempty"`

	// Maintenance mode config vsan mode
	// +kubebuilder:validation:Optional
	MaintenanceModeConfigVsanMode *string `json:"maintenanceModeConfigVsanMode,omitempty" tf:"maintenance_mode_config_vsan_mode,omitempty"`

	// Upgrade method to specify whether the upgrade is to be performed in parallel or serially
	// +kubebuilder:validation:Optional
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
	// +kubebuilder:validation:Optional
	PauseAfterEachUpgradeUnit *bool `json:"pauseAfterEachUpgradeUnit,omitempty" tf:"pause_after_each_upgrade_unit,omitempty"`

	// Rebootless upgrade
	// +kubebuilder:validation:Optional
	RebootlessUpgrade *bool `json:"rebootlessUpgrade,omitempty" tf:"rebootless_upgrade,omitempty"`

	// Upgrade mode
	// +kubebuilder:validation:Optional
	UpgradeMode *string `json:"upgradeMode,omitempty" tf:"upgrade_mode,omitempty"`
}

type HostUpgradeSettingObservation struct {

	// Whether run upgrade parallel
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Whether run post upgrade check
	PostUpgradeCheck *bool `json:"postUpgradeCheck,omitempty" tf:"post_upgrade_check,omitempty"`

	// Whether stop the upgrade when an error occur
	StopOnError *bool `json:"stopOnError,omitempty" tf:"stop_on_error,omitempty"`
}

type HostUpgradeSettingParameters struct {

	// Whether run upgrade parallel
	// +kubebuilder:validation:Optional
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Whether run post upgrade check
	// +kubebuilder:validation:Optional
	PostUpgradeCheck *bool `json:"postUpgradeCheck,omitempty" tf:"post_upgrade_check,omitempty"`

	// Whether stop the upgrade when an error occur
	// +kubebuilder:validation:Optional
	StopOnError *bool `json:"stopOnError,omitempty" tf:"stop_on_error,omitempty"`
}

type StateObservation struct {
	Details *string `json:"details,omitempty" tf:"details,omitempty"`

	GroupState []GroupStateObservation `json:"groupState,omitempty" tf:"group_state,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty" tf:"target_version,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type StateParameters struct {
}

type UpgradeGroupPlanObservation struct {

	// Flag to indicate whether upgrade of this group is enabled or not
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ExtendedConfig map[string]*string `json:"extendedConfig,omitempty" tf:"extended_config,omitempty"`

	// ID of upgrade unit group
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Upgrade method to specify whether the upgrade is to be performed in parallel or serially
	Parallel *bool `json:"parallel,omitempty" tf:"parallel,omitempty"`

	// Flag to indicate whether upgrade should be paused after upgrade of each upgrade-unit
	PauseAfterEachUpgradeUnit *bool `json:"pauseAfterEachUpgradeUnit,omitempty" tf:"pause_after_each_upgrade_unit,omitempty"`

	// Component type
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type UpgradeGroupPlanParameters struct {

	// +kubebuilder:validation:Optional
	ExtendedConfig map[string]*string `json:"extendedConfig,omitempty" tf:"extended_config,omitempty"`
}

type UpgradeRunObservation struct {

	// Initial delay to start upgrade status checks in seconds
	Delay *float64 `json:"delay,omitempty" tf:"delay,omitempty"`

	// Upgrade group for this upgrade
	EdgeGroup []EdgeGroupObservation `json:"edgeGroup,omitempty" tf:"edge_group,omitempty"`

	// Upgrade plan setting for component
	EdgeUpgradeSetting []EdgeUpgradeSettingObservation `json:"edgeUpgradeSetting,omitempty" tf:"edge_upgrade_setting,omitempty"`

	FinalizeUpgradeSetting []FinalizeUpgradeSettingObservation `json:"finalizeUpgradeSetting,omitempty" tf:"finalize_upgrade_setting,omitempty"`

	// Upgrade group for this upgrade
	HostGroup []HostGroupObservation `json:"hostGroup,omitempty" tf:"host_group,omitempty"`

	// Upgrade plan setting for component
	HostUpgradeSetting []HostUpgradeSettingObservation `json:"hostUpgradeSetting,omitempty" tf:"host_upgrade_setting,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Interval to check upgrade status in seconds
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Upgrade states
	State []StateObservation `json:"state,omitempty" tf:"state,omitempty"`

	// Upgrade status check timeout in seconds
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Upgrade plan for this upgrade
	UpgradeGroupPlan []UpgradeGroupPlanObservation `json:"upgradeGroupPlan,omitempty" tf:"upgrade_group_plan,omitempty"`

	// ID of corresponding nsxt_upgrade_prepare_ready resource
	UpgradePrepareReadyID *string `json:"upgradePrepareReadyId,omitempty" tf:"upgrade_prepare_ready_id,omitempty"`
}

type UpgradeRunParameters struct {

	// Initial delay to start upgrade status checks in seconds
	// +kubebuilder:validation:Optional
	Delay *float64 `json:"delay,omitempty" tf:"delay,omitempty"`

	// Upgrade group for this upgrade
	// +kubebuilder:validation:Optional
	EdgeGroup []EdgeGroupParameters `json:"edgeGroup,omitempty" tf:"edge_group,omitempty"`

	// Upgrade plan setting for component
	// +kubebuilder:validation:Optional
	EdgeUpgradeSetting []EdgeUpgradeSettingParameters `json:"edgeUpgradeSetting,omitempty" tf:"edge_upgrade_setting,omitempty"`

	// +kubebuilder:validation:Optional
	FinalizeUpgradeSetting []FinalizeUpgradeSettingParameters `json:"finalizeUpgradeSetting,omitempty" tf:"finalize_upgrade_setting,omitempty"`

	// Upgrade group for this upgrade
	// +kubebuilder:validation:Optional
	HostGroup []HostGroupParameters `json:"hostGroup,omitempty" tf:"host_group,omitempty"`

	// Upgrade plan setting for component
	// +kubebuilder:validation:Optional
	HostUpgradeSetting []HostUpgradeSettingParameters `json:"hostUpgradeSetting,omitempty" tf:"host_upgrade_setting,omitempty"`

	// Interval to check upgrade status in seconds
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// Upgrade status check timeout in seconds
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`

	// Upgrade plan for this upgrade
	// +kubebuilder:validation:Optional
	UpgradeGroupPlan []UpgradeGroupPlanParameters `json:"upgradeGroupPlan,omitempty" tf:"upgrade_group_plan,omitempty"`

	// ID of corresponding nsxt_upgrade_prepare_ready resource
	// +kubebuilder:validation:Optional
	UpgradePrepareReadyID *string `json:"upgradePrepareReadyId,omitempty" tf:"upgrade_prepare_ready_id,omitempty"`
}

// UpgradeRunSpec defines the desired state of UpgradeRun
type UpgradeRunSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     UpgradeRunParameters `json:"forProvider"`
}

// UpgradeRunStatus defines the observed state of UpgradeRun.
type UpgradeRunStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        UpgradeRunObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// UpgradeRun is the Schema for the UpgradeRuns API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type UpgradeRun struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.upgradePrepareReadyId)",message="upgradePrepareReadyId is a required parameter"
	Spec   UpgradeRunSpec   `json:"spec"`
	Status UpgradeRunStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// UpgradeRunList contains a list of UpgradeRuns
type UpgradeRunList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []UpgradeRun `json:"items"`
}

// Repository type metadata.
var (
	UpgradeRun_Kind             = "UpgradeRun"
	UpgradeRun_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: UpgradeRun_Kind}.String()
	UpgradeRun_KindAPIVersion   = UpgradeRun_Kind + "." + CRDGroupVersion.String()
	UpgradeRun_GroupVersionKind = CRDGroupVersion.WithKind(UpgradeRun_Kind)
)

func init() {
	SchemeBuilder.Register(&UpgradeRun{}, &UpgradeRunList{})
}
