/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BodyConditionObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type BodyConditionParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type CookieConditionObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type CookieConditionParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type HTTPRedirectActionObservation struct {
	RedirectStatus *string `json:"redirectStatus,omitempty" tf:"redirect_status,omitempty"`

	RedirectURL *string `json:"redirectUrl,omitempty" tf:"redirect_url,omitempty"`
}

type HTTPRedirectActionParameters struct {

	// +kubebuilder:validation:Required
	RedirectStatus *string `json:"redirectStatus" tf:"redirect_status,omitempty"`

	// +kubebuilder:validation:Required
	RedirectURL *string `json:"redirectUrl" tf:"redirect_url,omitempty"`
}

type HTTPRejectActionObservation struct {
	ReplyMessage *string `json:"replyMessage,omitempty" tf:"reply_message,omitempty"`

	ReplyStatus *string `json:"replyStatus,omitempty" tf:"reply_status,omitempty"`
}

type HTTPRejectActionParameters struct {

	// +kubebuilder:validation:Required
	ReplyMessage *string `json:"replyMessage" tf:"reply_message,omitempty"`

	// +kubebuilder:validation:Required
	ReplyStatus *string `json:"replyStatus" tf:"reply_status,omitempty"`
}

type HeaderConditionObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HeaderConditionParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type IPConditionObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	SourceAddress *string `json:"sourceAddress,omitempty" tf:"source_address,omitempty"`
}

type IPConditionParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	SourceAddress *string `json:"sourceAddress" tf:"source_address,omitempty"`
}

type LbHttpForwardingRuleObservation struct {

	// Rule condition based on http request body
	BodyCondition []BodyConditionObservation `json:"bodyCondition,omitempty" tf:"body_condition,omitempty"`

	// Rule condition based on http header
	CookieCondition []CookieConditionObservation `json:"cookieCondition,omitempty" tf:"cookie_condition,omitempty"`

	// Description of this resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The display name of this resource. Defaults to ID if not set
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Redirect the request with a defined status and url
	HTTPRedirectAction []HTTPRedirectActionObservation `json:"httpRedirectAction,omitempty" tf:"http_redirect_action,omitempty"`

	// Reject the request with a defined status and message
	HTTPRejectAction []HTTPRejectActionObservation `json:"httpRejectAction,omitempty" tf:"http_reject_action,omitempty"`

	// Rule condition based on http header
	HeaderCondition []HeaderConditionObservation `json:"headerCondition,omitempty" tf:"header_condition,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Rule condition based on IP settings of the message
	IPCondition []IPConditionObservation `json:"ipCondition,omitempty" tf:"ip_condition,omitempty"`

	// Strategy when multiple match conditions are specified in one rule (ANY vs ALL)
	MatchStrategy *string `json:"matchStrategy,omitempty" tf:"match_strategy,omitempty"`

	// Rule condition based on http request method
	MethodCondition []MethodConditionObservation `json:"methodCondition,omitempty" tf:"method_condition,omitempty"`

	// The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
	Revision *float64 `json:"revision,omitempty" tf:"revision,omitempty"`

	// Forward the request to the a defined pool
	SelectPoolAction []SelectPoolActionObservation `json:"selectPoolAction,omitempty" tf:"select_pool_action,omitempty"`

	// Rule condition based on TCP settings of the message
	TCPCondition []TCPConditionObservation `json:"tcpCondition,omitempty" tf:"tcp_condition,omitempty"`

	// Set of opaque identifiers meaningful to the user
	Tag []LbHttpForwardingRuleTagObservation `json:"tag,omitempty" tf:"tag,omitempty"`

	// Rule condition based on http request URI
	URICondition []URIConditionObservation `json:"uriCondition,omitempty" tf:"uri_condition,omitempty"`

	// Rule condition based on http request version
	VersionCondition []VersionConditionObservation `json:"versionCondition,omitempty" tf:"version_condition,omitempty"`
}

type LbHttpForwardingRuleParameters struct {

	// Rule condition based on http request body
	// +kubebuilder:validation:Optional
	BodyCondition []BodyConditionParameters `json:"bodyCondition,omitempty" tf:"body_condition,omitempty"`

	// Rule condition based on http header
	// +kubebuilder:validation:Optional
	CookieCondition []CookieConditionParameters `json:"cookieCondition,omitempty" tf:"cookie_condition,omitempty"`

	// Description of this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The display name of this resource. Defaults to ID if not set
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Redirect the request with a defined status and url
	// +kubebuilder:validation:Optional
	HTTPRedirectAction []HTTPRedirectActionParameters `json:"httpRedirectAction,omitempty" tf:"http_redirect_action,omitempty"`

	// Reject the request with a defined status and message
	// +kubebuilder:validation:Optional
	HTTPRejectAction []HTTPRejectActionParameters `json:"httpRejectAction,omitempty" tf:"http_reject_action,omitempty"`

	// Rule condition based on http header
	// +kubebuilder:validation:Optional
	HeaderCondition []HeaderConditionParameters `json:"headerCondition,omitempty" tf:"header_condition,omitempty"`

	// Rule condition based on IP settings of the message
	// +kubebuilder:validation:Optional
	IPCondition []IPConditionParameters `json:"ipCondition,omitempty" tf:"ip_condition,omitempty"`

	// Strategy when multiple match conditions are specified in one rule (ANY vs ALL)
	// +kubebuilder:validation:Optional
	MatchStrategy *string `json:"matchStrategy,omitempty" tf:"match_strategy,omitempty"`

	// Rule condition based on http request method
	// +kubebuilder:validation:Optional
	MethodCondition []MethodConditionParameters `json:"methodCondition,omitempty" tf:"method_condition,omitempty"`

	// Forward the request to the a defined pool
	// +kubebuilder:validation:Optional
	SelectPoolAction []SelectPoolActionParameters `json:"selectPoolAction,omitempty" tf:"select_pool_action,omitempty"`

	// Rule condition based on TCP settings of the message
	// +kubebuilder:validation:Optional
	TCPCondition []TCPConditionParameters `json:"tcpCondition,omitempty" tf:"tcp_condition,omitempty"`

	// Set of opaque identifiers meaningful to the user
	// +kubebuilder:validation:Optional
	Tag []LbHttpForwardingRuleTagParameters `json:"tag,omitempty" tf:"tag,omitempty"`

	// Rule condition based on http request URI
	// +kubebuilder:validation:Optional
	URICondition []URIConditionParameters `json:"uriCondition,omitempty" tf:"uri_condition,omitempty"`

	// Rule condition based on http request version
	// +kubebuilder:validation:Optional
	VersionCondition []VersionConditionParameters `json:"versionCondition,omitempty" tf:"version_condition,omitempty"`
}

type LbHttpForwardingRuleTagObservation struct {
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type LbHttpForwardingRuleTagParameters struct {

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type MethodConditionObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	Method *string `json:"method,omitempty" tf:"method,omitempty"`
}

type MethodConditionParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	Method *string `json:"method" tf:"method,omitempty"`
}

type SelectPoolActionObservation struct {
	PoolID *string `json:"poolId,omitempty" tf:"pool_id,omitempty"`
}

type SelectPoolActionParameters struct {

	// +kubebuilder:validation:Required
	PoolID *string `json:"poolId" tf:"pool_id,omitempty"`
}

type TCPConditionObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	SourcePort *string `json:"sourcePort,omitempty" tf:"source_port,omitempty"`
}

type TCPConditionParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	SourcePort *string `json:"sourcePort" tf:"source_port,omitempty"`
}

type URIConditionObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`
}

type URIConditionParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type VersionConditionObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type VersionConditionParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

// LbHttpForwardingRuleSpec defines the desired state of LbHttpForwardingRule
type LbHttpForwardingRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     LbHttpForwardingRuleParameters `json:"forProvider"`
}

// LbHttpForwardingRuleStatus defines the observed state of LbHttpForwardingRule.
type LbHttpForwardingRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        LbHttpForwardingRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// LbHttpForwardingRule is the Schema for the LbHttpForwardingRules API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type LbHttpForwardingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              LbHttpForwardingRuleSpec   `json:"spec"`
	Status            LbHttpForwardingRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// LbHttpForwardingRuleList contains a list of LbHttpForwardingRules
type LbHttpForwardingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []LbHttpForwardingRule `json:"items"`
}

// Repository type metadata.
var (
	LbHttpForwardingRule_Kind             = "LbHttpForwardingRule"
	LbHttpForwardingRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: LbHttpForwardingRule_Kind}.String()
	LbHttpForwardingRule_KindAPIVersion   = LbHttpForwardingRule_Kind + "." + CRDGroupVersion.String()
	LbHttpForwardingRule_GroupVersionKind = CRDGroupVersion.WithKind(LbHttpForwardingRule_Kind)
)

func init() {
	SchemeBuilder.Register(&LbHttpForwardingRule{}, &LbHttpForwardingRuleList{})
}
