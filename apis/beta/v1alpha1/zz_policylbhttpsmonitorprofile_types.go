/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type PolicyLbHttpsMonitorProfileObservation struct {

	// Description for this resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Number of consecutive checks that must fail before marking it down
	FallCount *float64 `json:"fallCount,omitempty" tf:"fall_count,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The frequency at which the system issues the monitor check (in seconds)
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// If the monitor port is specified, it would override pool member port setting for healthcheck. A port range is not supported
	MonitorPort *float64 `json:"monitorPort,omitempty" tf:"monitor_port,omitempty"`

	// NSX ID for this resource
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// Policy path for this resource
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// String to send as HTTP health check request body. Valid only for certain HTTP methods like POST
	RequestBody *string `json:"requestBody,omitempty" tf:"request_body,omitempty"`

	// Array of HTTP request headers
	RequestHeader []PolicyLbHttpsMonitorProfileRequestHeaderObservation `json:"requestHeader,omitempty" tf:"request_header,omitempty"`

	// Health check method for HTTP monitor type
	RequestMethod *string `json:"requestMethod,omitempty" tf:"request_method,omitempty"`

	// URL used for HTTP monitor
	RequestURL *string `json:"requestUrl,omitempty" tf:"request_url,omitempty"`

	// HTTP request version
	RequestVersion *string `json:"requestVersion,omitempty" tf:"request_version,omitempty"`

	// If HTTP specified, healthcheck HTTP response body is matched against the specified string (regular expressions not supported), and succeeds only if there is a match
	ResponseBody *string `json:"responseBody,omitempty" tf:"response_body,omitempty"`

	// The HTTP response status code should be a valid HTTP status code
	ResponseStatusCodes []*float64 `json:"responseStatusCodes,omitempty" tf:"response_status_codes,omitempty"`

	// The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
	Revision *float64 `json:"revision,omitempty" tf:"revision,omitempty"`

	// Number of consecutive checks that must pass before marking it up
	RiseCount *float64 `json:"riseCount,omitempty" tf:"rise_count,omitempty"`

	ServerSSL []ServerSSLObservation `json:"serverSsl,omitempty" tf:"server_ssl,omitempty"`

	// Set of opaque identifiers meaningful to the user
	Tag []PolicyLbHttpsMonitorProfileTagObservation `json:"tag,omitempty" tf:"tag,omitempty"`

	// Number of seconds the target has to respond to the monitor request
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type PolicyLbHttpsMonitorProfileParameters struct {

	// Description for this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Number of consecutive checks that must fail before marking it down
	// +kubebuilder:validation:Optional
	FallCount *float64 `json:"fallCount,omitempty" tf:"fall_count,omitempty"`

	// The frequency at which the system issues the monitor check (in seconds)
	// +kubebuilder:validation:Optional
	Interval *float64 `json:"interval,omitempty" tf:"interval,omitempty"`

	// If the monitor port is specified, it would override pool member port setting for healthcheck. A port range is not supported
	// +kubebuilder:validation:Optional
	MonitorPort *float64 `json:"monitorPort,omitempty" tf:"monitor_port,omitempty"`

	// NSX ID for this resource
	// +kubebuilder:validation:Optional
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// String to send as HTTP health check request body. Valid only for certain HTTP methods like POST
	// +kubebuilder:validation:Optional
	RequestBody *string `json:"requestBody,omitempty" tf:"request_body,omitempty"`

	// Array of HTTP request headers
	// +kubebuilder:validation:Optional
	RequestHeader []PolicyLbHttpsMonitorProfileRequestHeaderParameters `json:"requestHeader,omitempty" tf:"request_header,omitempty"`

	// Health check method for HTTP monitor type
	// +kubebuilder:validation:Optional
	RequestMethod *string `json:"requestMethod,omitempty" tf:"request_method,omitempty"`

	// URL used for HTTP monitor
	// +kubebuilder:validation:Optional
	RequestURL *string `json:"requestUrl,omitempty" tf:"request_url,omitempty"`

	// HTTP request version
	// +kubebuilder:validation:Optional
	RequestVersion *string `json:"requestVersion,omitempty" tf:"request_version,omitempty"`

	// If HTTP specified, healthcheck HTTP response body is matched against the specified string (regular expressions not supported), and succeeds only if there is a match
	// +kubebuilder:validation:Optional
	ResponseBody *string `json:"responseBody,omitempty" tf:"response_body,omitempty"`

	// The HTTP response status code should be a valid HTTP status code
	// +kubebuilder:validation:Optional
	ResponseStatusCodes []*float64 `json:"responseStatusCodes,omitempty" tf:"response_status_codes,omitempty"`

	// Number of consecutive checks that must pass before marking it up
	// +kubebuilder:validation:Optional
	RiseCount *float64 `json:"riseCount,omitempty" tf:"rise_count,omitempty"`

	// +kubebuilder:validation:Optional
	ServerSSL []ServerSSLParameters `json:"serverSsl,omitempty" tf:"server_ssl,omitempty"`

	// Set of opaque identifiers meaningful to the user
	// +kubebuilder:validation:Optional
	Tag []PolicyLbHttpsMonitorProfileTagParameters `json:"tag,omitempty" tf:"tag,omitempty"`

	// Number of seconds the target has to respond to the monitor request
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type PolicyLbHttpsMonitorProfileRequestHeaderObservation struct {

	// Header name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Header value
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PolicyLbHttpsMonitorProfileRequestHeaderParameters struct {

	// Header name
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Header value
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type PolicyLbHttpsMonitorProfileTagObservation struct {
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type PolicyLbHttpsMonitorProfileTagParameters struct {

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type ServerSSLObservation struct {

	// Authentication depth is used to set the verification depth in the server certificates chain. format: int64
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client certificate path
	ClientCertificatePath *string `json:"clientCertificatePath,omitempty" tf:"client_certificate_path,omitempty"`

	// SSL profile path
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// Server authentication mode.
	ServerAuth *string `json:"serverAuth,omitempty" tf:"server_auth,omitempty"`

	// If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified.
	ServerAuthCAPaths []*string `json:"serverAuthCaPaths,omitempty" tf:"server_auth_ca_paths,omitempty"`

	// A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates.
	ServerAuthCrlPaths []*string `json:"serverAuthCrlPaths,omitempty" tf:"server_auth_crl_paths,omitempty"`
}

type ServerSSLParameters struct {

	// Authentication depth is used to set the verification depth in the server certificates chain. format: int64
	// +kubebuilder:validation:Optional
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client certificate path
	// +kubebuilder:validation:Optional
	ClientCertificatePath *string `json:"clientCertificatePath,omitempty" tf:"client_certificate_path,omitempty"`

	// SSL profile path
	// +kubebuilder:validation:Optional
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// Server authentication mode.
	// +kubebuilder:validation:Optional
	ServerAuth *string `json:"serverAuth,omitempty" tf:"server_auth,omitempty"`

	// If server auth type is REQUIRED, server certificate must be signed by one of the trusted Certificate Authorities (CAs), also referred to as root CAs, whose self signed certificates are specified.
	// +kubebuilder:validation:Optional
	ServerAuthCAPaths []*string `json:"serverAuthCaPaths,omitempty" tf:"server_auth_ca_paths,omitempty"`

	// A Certificate Revocation List (CRL) can be specified in the server-side SSL profile binding to disallow compromised server certificates.
	// +kubebuilder:validation:Optional
	ServerAuthCrlPaths []*string `json:"serverAuthCrlPaths,omitempty" tf:"server_auth_crl_paths,omitempty"`
}

// PolicyLbHttpsMonitorProfileSpec defines the desired state of PolicyLbHttpsMonitorProfile
type PolicyLbHttpsMonitorProfileSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PolicyLbHttpsMonitorProfileParameters `json:"forProvider"`
}

// PolicyLbHttpsMonitorProfileStatus defines the observed state of PolicyLbHttpsMonitorProfile.
type PolicyLbHttpsMonitorProfileStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PolicyLbHttpsMonitorProfileObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbHttpsMonitorProfile is the Schema for the PolicyLbHttpsMonitorProfiles API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type PolicyLbHttpsMonitorProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.displayName)",message="displayName is a required parameter"
	Spec   PolicyLbHttpsMonitorProfileSpec   `json:"spec"`
	Status PolicyLbHttpsMonitorProfileStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbHttpsMonitorProfileList contains a list of PolicyLbHttpsMonitorProfiles
type PolicyLbHttpsMonitorProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PolicyLbHttpsMonitorProfile `json:"items"`
}

// Repository type metadata.
var (
	PolicyLbHttpsMonitorProfile_Kind             = "PolicyLbHttpsMonitorProfile"
	PolicyLbHttpsMonitorProfile_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PolicyLbHttpsMonitorProfile_Kind}.String()
	PolicyLbHttpsMonitorProfile_KindAPIVersion   = PolicyLbHttpsMonitorProfile_Kind + "." + CRDGroupVersion.String()
	PolicyLbHttpsMonitorProfile_GroupVersionKind = CRDGroupVersion.WithKind(PolicyLbHttpsMonitorProfile_Kind)
)

func init() {
	SchemeBuilder.Register(&PolicyLbHttpsMonitorProfile{}, &PolicyLbHttpsMonitorProfileList{})
}
