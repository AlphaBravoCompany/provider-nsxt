/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessListControlObservation struct {

	// Action to apply to connections matching the group
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// Flag to enable access list control
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The path of grouping object which defines the IP addresses or ranges to match the client IP
	GroupPath *string `json:"groupPath,omitempty" tf:"group_path,omitempty"`
}

type AccessListControlParameters struct {

	// Action to apply to connections matching the group
	// +kubebuilder:validation:Required
	Action *string `json:"action" tf:"action,omitempty"`

	// Flag to enable access list control
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// The path of grouping object which defines the IP addresses or ranges to match the client IP
	// +kubebuilder:validation:Required
	GroupPath *string `json:"groupPath" tf:"group_path,omitempty"`
}

type ActionObservation struct {

	// Action to drop the connection.
	ConnectionDrop []ConnectionDropObservation `json:"connectionDrop,omitempty" tf:"connection_drop,omitempty"`

	// Action to redirect HTTP request messages to a new URL.
	HTTPRedirect []HTTPRedirectObservation `json:"httpRedirect,omitempty" tf:"http_redirect,omitempty"`

	// Action to reject HTTP request messages
	HTTPReject []HTTPRejectObservation `json:"httpReject,omitempty" tf:"http_reject,omitempty"`

	// Action to delete header fields of HTTP request messages at HTTP_REQUEST_REWRITE phase.
	HTTPRequestHeaderDelete []HTTPRequestHeaderDeleteObservation `json:"httpRequestHeaderDelete,omitempty" tf:"http_request_header_delete,omitempty"`

	// Action to rewrite header fields of HTTP request messages to specified new values at HTTP_REQUEST_REWRITE phase.
	HTTPRequestHeaderRewrite []HTTPRequestHeaderRewriteObservation `json:"httpRequestHeaderRewrite,omitempty" tf:"http_request_header_rewrite,omitempty"`

	// Action to rewrite URIs in matched HTTP request messages.
	HTTPRequestURIRewrite []HTTPRequestURIRewriteObservation `json:"httpRequestUriRewrite,omitempty" tf:"http_request_uri_rewrite,omitempty"`

	// Action to delete header fields of HTTP response messages at HTTP_RESPONSE_REWRITE phase.
	HTTPResponseHeaderDelete []HTTPResponseHeaderDeleteObservation `json:"httpResponseHeaderDelete,omitempty" tf:"http_response_header_delete,omitempty"`

	// Action to rewrite header fields of HTTP response messages to specified new values at HTTP_RESPONSE_REWRITE phase.
	HTTPResponseHeaderRewrite []HTTPResponseHeaderRewriteObservation `json:"httpResponseHeaderRewrite,omitempty" tf:"http_response_header_rewrite,omitempty"`

	// Action  to control access to backend server resources using JSON Web Token(JWT) authentication.
	JwtAuth []JwtAuthObservation `json:"jwtAuth,omitempty" tf:"jwt_auth,omitempty"`

	// Action to select SSL mode.
	SSLModeSelection []SSLModeSelectionObservation `json:"sslModeSelection,omitempty" tf:"ssl_mode_selection,omitempty"`

	// Action to select a pool for matched HTTP request messages.
	SelectPool []SelectPoolObservation `json:"selectPool,omitempty" tf:"select_pool,omitempty"`

	// Action to create a new variable and assign value to it.
	VariableAssignment []VariableAssignmentObservation `json:"variableAssignment,omitempty" tf:"variable_assignment,omitempty"`

	// Action to create a new variable and assign value to it.
	VariablePersistenceLearn []VariablePersistenceLearnObservation `json:"variablePersistenceLearn,omitempty" tf:"variable_persistence_learn,omitempty"`

	// Action to create a new variable and assign value to it.
	VariablePersistenceOn []VariablePersistenceOnObservation `json:"variablePersistenceOn,omitempty" tf:"variable_persistence_on,omitempty"`
}

type ActionParameters struct {

	// Action to drop the connection.
	// +kubebuilder:validation:Optional
	ConnectionDrop []ConnectionDropParameters `json:"connectionDrop,omitempty" tf:"connection_drop,omitempty"`

	// Action to redirect HTTP request messages to a new URL.
	// +kubebuilder:validation:Optional
	HTTPRedirect []HTTPRedirectParameters `json:"httpRedirect,omitempty" tf:"http_redirect,omitempty"`

	// Action to reject HTTP request messages
	// +kubebuilder:validation:Optional
	HTTPReject []HTTPRejectParameters `json:"httpReject,omitempty" tf:"http_reject,omitempty"`

	// Action to delete header fields of HTTP request messages at HTTP_REQUEST_REWRITE phase.
	// +kubebuilder:validation:Optional
	HTTPRequestHeaderDelete []HTTPRequestHeaderDeleteParameters `json:"httpRequestHeaderDelete,omitempty" tf:"http_request_header_delete,omitempty"`

	// Action to rewrite header fields of HTTP request messages to specified new values at HTTP_REQUEST_REWRITE phase.
	// +kubebuilder:validation:Optional
	HTTPRequestHeaderRewrite []HTTPRequestHeaderRewriteParameters `json:"httpRequestHeaderRewrite,omitempty" tf:"http_request_header_rewrite,omitempty"`

	// Action to rewrite URIs in matched HTTP request messages.
	// +kubebuilder:validation:Optional
	HTTPRequestURIRewrite []HTTPRequestURIRewriteParameters `json:"httpRequestUriRewrite,omitempty" tf:"http_request_uri_rewrite,omitempty"`

	// Action to delete header fields of HTTP response messages at HTTP_RESPONSE_REWRITE phase.
	// +kubebuilder:validation:Optional
	HTTPResponseHeaderDelete []HTTPResponseHeaderDeleteParameters `json:"httpResponseHeaderDelete,omitempty" tf:"http_response_header_delete,omitempty"`

	// Action to rewrite header fields of HTTP response messages to specified new values at HTTP_RESPONSE_REWRITE phase.
	// +kubebuilder:validation:Optional
	HTTPResponseHeaderRewrite []HTTPResponseHeaderRewriteParameters `json:"httpResponseHeaderRewrite,omitempty" tf:"http_response_header_rewrite,omitempty"`

	// Action  to control access to backend server resources using JSON Web Token(JWT) authentication.
	// +kubebuilder:validation:Optional
	JwtAuth []JwtAuthParameters `json:"jwtAuth,omitempty" tf:"jwt_auth,omitempty"`

	// Action to select SSL mode.
	// +kubebuilder:validation:Optional
	SSLModeSelection []SSLModeSelectionParameters `json:"sslModeSelection,omitempty" tf:"ssl_mode_selection,omitempty"`

	// Action to select a pool for matched HTTP request messages.
	// +kubebuilder:validation:Optional
	SelectPool []SelectPoolParameters `json:"selectPool,omitempty" tf:"select_pool,omitempty"`

	// Action to create a new variable and assign value to it.
	// +kubebuilder:validation:Optional
	VariableAssignment []VariableAssignmentParameters `json:"variableAssignment,omitempty" tf:"variable_assignment,omitempty"`

	// Action to create a new variable and assign value to it.
	// +kubebuilder:validation:Optional
	VariablePersistenceLearn []VariablePersistenceLearnParameters `json:"variablePersistenceLearn,omitempty" tf:"variable_persistence_learn,omitempty"`

	// Action to create a new variable and assign value to it.
	// +kubebuilder:validation:Optional
	VariablePersistenceOn []VariablePersistenceOnParameters `json:"variablePersistenceOn,omitempty" tf:"variable_persistence_on,omitempty"`
}

type ClientCertificateIssuerDnObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	IssuerDn *string `json:"issuerDn,omitempty" tf:"issuer_dn,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`
}

type ClientCertificateIssuerDnParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// +kubebuilder:validation:Required
	IssuerDn *string `json:"issuerDn" tf:"issuer_dn,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`
}

type ClientCertificateSubjectDnObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	SubjectDn *string `json:"subjectDn,omitempty" tf:"subject_dn,omitempty"`
}

type ClientCertificateSubjectDnParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	SubjectDn *string `json:"subjectDn" tf:"subject_dn,omitempty"`
}

type ClientSSLObservation struct {

	// If client auth type is REQUIRED, client certificate must be signed by one Certificate Authorities
	CAPaths []*string `json:"caPaths,omitempty" tf:"ca_paths,omitempty"`

	// Certificate chain depth
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client authentication mode
	ClientAuth *string `json:"clientAuth,omitempty" tf:"client_auth,omitempty"`

	// Certificate Revocation Lists can be specified to disallow compromised certificates
	CrlPaths []*string `json:"crlPaths,omitempty" tf:"crl_paths,omitempty"`

	// Default Certificate Path
	DefaultCertificatePath *string `json:"defaultCertificatePath,omitempty" tf:"default_certificate_path,omitempty"`

	// Client SSL Profile Path
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// This setting allows multiple certificates, for different hostnames, to be bound to the same virtual server
	SniPaths []*string `json:"sniPaths,omitempty" tf:"sni_paths,omitempty"`
}

type ClientSSLParameters struct {

	// If client auth type is REQUIRED, client certificate must be signed by one Certificate Authorities
	// +kubebuilder:validation:Optional
	CAPaths []*string `json:"caPaths,omitempty" tf:"ca_paths,omitempty"`

	// Certificate chain depth
	// +kubebuilder:validation:Optional
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client authentication mode
	// +kubebuilder:validation:Optional
	ClientAuth *string `json:"clientAuth,omitempty" tf:"client_auth,omitempty"`

	// Certificate Revocation Lists can be specified to disallow compromised certificates
	// +kubebuilder:validation:Optional
	CrlPaths []*string `json:"crlPaths,omitempty" tf:"crl_paths,omitempty"`

	// Default Certificate Path
	// +kubebuilder:validation:Required
	DefaultCertificatePath *string `json:"defaultCertificatePath" tf:"default_certificate_path,omitempty"`

	// Client SSL Profile Path
	// +kubebuilder:validation:Optional
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// This setting allows multiple certificates, for different hostnames, to be bound to the same virtual server
	// +kubebuilder:validation:Optional
	SniPaths []*string `json:"sniPaths,omitempty" tf:"sni_paths,omitempty"`
}

type ConditionObservation struct {

	// Rule condition based on HTTP request body
	HTTPRequestBody []HTTPRequestBodyObservation `json:"httpRequestBody,omitempty" tf:"http_request_body,omitempty"`

	// Rule condition based on HTTP cookie
	HTTPRequestCookie []HTTPRequestCookieObservation `json:"httpRequestCookie,omitempty" tf:"http_request_cookie,omitempty"`

	// Rule condition based on HTTP request header
	HTTPRequestHeader []HTTPRequestHeaderObservation `json:"httpRequestHeader,omitempty" tf:"http_request_header,omitempty"`

	// Rule condition based on http request method
	HTTPRequestMethod []HTTPRequestMethodObservation `json:"httpRequestMethod,omitempty" tf:"http_request_method,omitempty"`

	// Rule condition based on http request URI
	HTTPRequestURI []HTTPRequestURIObservation `json:"httpRequestUri,omitempty" tf:"http_request_uri,omitempty"`

	// Rule condition based on http request URI arguments (query string)
	HTTPRequestURIArguments []HTTPRequestURIArgumentsObservation `json:"httpRequestUriArguments,omitempty" tf:"http_request_uri_arguments,omitempty"`

	// Rule condition based on http request version
	HTTPRequestVersion []HTTPRequestVersionObservation `json:"httpRequestVersion,omitempty" tf:"http_request_version,omitempty"`

	// Rule condition based on HTTP response header
	HTTPResponseHeader []HTTPResponseHeaderObservation `json:"httpResponseHeader,omitempty" tf:"http_response_header,omitempty"`

	// Rule condition based on HTTP SSL handshake and connection
	HTTPSSL []HTTPSSLObservation `json:"httpSsl,omitempty" tf:"http_ssl,omitempty"`

	// Rule condition based on IP settings of the message
	IPHeader []IPHeaderObservation `json:"ipHeader,omitempty" tf:"ip_header,omitempty"`

	// Rule condition based on SSL SNI in client hello
	SSLSni []SSLSniObservation `json:"sslSni,omitempty" tf:"ssl_sni,omitempty"`

	// Rule condition based on TCP settings of the message
	TCPHeader []TCPHeaderObservation `json:"tcpHeader,omitempty" tf:"tcp_header,omitempty"`

	// Rule condition based on IP header
	Variable []VariableObservation `json:"variable,omitempty" tf:"variable,omitempty"`
}

type ConditionParameters struct {

	// Rule condition based on HTTP request body
	// +kubebuilder:validation:Optional
	HTTPRequestBody []HTTPRequestBodyParameters `json:"httpRequestBody,omitempty" tf:"http_request_body,omitempty"`

	// Rule condition based on HTTP cookie
	// +kubebuilder:validation:Optional
	HTTPRequestCookie []HTTPRequestCookieParameters `json:"httpRequestCookie,omitempty" tf:"http_request_cookie,omitempty"`

	// Rule condition based on HTTP request header
	// +kubebuilder:validation:Optional
	HTTPRequestHeader []HTTPRequestHeaderParameters `json:"httpRequestHeader,omitempty" tf:"http_request_header,omitempty"`

	// Rule condition based on http request method
	// +kubebuilder:validation:Optional
	HTTPRequestMethod []HTTPRequestMethodParameters `json:"httpRequestMethod,omitempty" tf:"http_request_method,omitempty"`

	// Rule condition based on http request URI
	// +kubebuilder:validation:Optional
	HTTPRequestURI []HTTPRequestURIParameters `json:"httpRequestUri,omitempty" tf:"http_request_uri,omitempty"`

	// Rule condition based on http request URI arguments (query string)
	// +kubebuilder:validation:Optional
	HTTPRequestURIArguments []HTTPRequestURIArgumentsParameters `json:"httpRequestUriArguments,omitempty" tf:"http_request_uri_arguments,omitempty"`

	// Rule condition based on http request version
	// +kubebuilder:validation:Optional
	HTTPRequestVersion []HTTPRequestVersionParameters `json:"httpRequestVersion,omitempty" tf:"http_request_version,omitempty"`

	// Rule condition based on HTTP response header
	// +kubebuilder:validation:Optional
	HTTPResponseHeader []HTTPResponseHeaderParameters `json:"httpResponseHeader,omitempty" tf:"http_response_header,omitempty"`

	// Rule condition based on HTTP SSL handshake and connection
	// +kubebuilder:validation:Optional
	HTTPSSL []HTTPSSLParameters `json:"httpSsl,omitempty" tf:"http_ssl,omitempty"`

	// Rule condition based on IP settings of the message
	// +kubebuilder:validation:Optional
	IPHeader []IPHeaderParameters `json:"ipHeader,omitempty" tf:"ip_header,omitempty"`

	// Rule condition based on SSL SNI in client hello
	// +kubebuilder:validation:Optional
	SSLSni []SSLSniParameters `json:"sslSni,omitempty" tf:"ssl_sni,omitempty"`

	// Rule condition based on TCP settings of the message
	// +kubebuilder:validation:Optional
	TCPHeader []TCPHeaderParameters `json:"tcpHeader,omitempty" tf:"tcp_header,omitempty"`

	// Rule condition based on IP header
	// +kubebuilder:validation:Optional
	Variable []VariableParameters `json:"variable,omitempty" tf:"variable,omitempty"`
}

type ConnectionDropObservation struct {
	Dummy *string `json:"Dummy,omitempty" tf:"_dummy,omitempty"`
}

type ConnectionDropParameters struct {

	// +kubebuilder:validation:Optional
	Dummy *string `json:"Dummy,omitempty" tf:"_dummy,omitempty"`
}

type HTTPRedirectObservation struct {
	RedirectStatus *string `json:"redirectStatus,omitempty" tf:"redirect_status,omitempty"`

	RedirectURL *string `json:"redirectUrl,omitempty" tf:"redirect_url,omitempty"`
}

type HTTPRedirectParameters struct {

	// +kubebuilder:validation:Required
	RedirectStatus *string `json:"redirectStatus" tf:"redirect_status,omitempty"`

	// +kubebuilder:validation:Required
	RedirectURL *string `json:"redirectUrl" tf:"redirect_url,omitempty"`
}

type HTTPRejectObservation struct {
	ReplyMessage *string `json:"replyMessage,omitempty" tf:"reply_message,omitempty"`

	ReplyStatus *string `json:"replyStatus,omitempty" tf:"reply_status,omitempty"`
}

type HTTPRejectParameters struct {

	// +kubebuilder:validation:Optional
	ReplyMessage *string `json:"replyMessage,omitempty" tf:"reply_message,omitempty"`

	// +kubebuilder:validation:Required
	ReplyStatus *string `json:"replyStatus" tf:"reply_status,omitempty"`
}

type HTTPRequestBodyObservation struct {
	BodyValue *string `json:"bodyValue,omitempty" tf:"body_value,omitempty"`

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`
}

type HTTPRequestBodyParameters struct {

	// +kubebuilder:validation:Required
	BodyValue *string `json:"bodyValue" tf:"body_value,omitempty"`

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`
}

type HTTPRequestCookieObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	CookieName *string `json:"cookieName,omitempty" tf:"cookie_name,omitempty"`

	CookieValue *string `json:"cookieValue,omitempty" tf:"cookie_value,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`
}

type HTTPRequestCookieParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// +kubebuilder:validation:Required
	CookieName *string `json:"cookieName" tf:"cookie_name,omitempty"`

	// +kubebuilder:validation:Required
	CookieValue *string `json:"cookieValue" tf:"cookie_value,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`
}

type HTTPRequestHeaderDeleteObservation struct {
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type HTTPRequestHeaderDeleteParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type HTTPRequestHeaderObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`
}

type HTTPRequestHeaderParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`
}

type HTTPRequestHeaderRewriteObservation struct {
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`
}

type HTTPRequestHeaderRewriteParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`
}

type HTTPRequestMethodObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	Method *string `json:"method,omitempty" tf:"method,omitempty"`
}

type HTTPRequestMethodParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	Method *string `json:"method" tf:"method,omitempty"`
}

type HTTPRequestURIArgumentsObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	URIArguments *string `json:"uriArguments,omitempty" tf:"uri_arguments,omitempty"`
}

type HTTPRequestURIArgumentsParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	URIArguments *string `json:"uriArguments" tf:"uri_arguments,omitempty"`
}

type HTTPRequestURIObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`
}

type HTTPRequestURIParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`
}

type HTTPRequestURIRewriteObservation struct {
	URI *string `json:"uri,omitempty" tf:"uri,omitempty"`

	URIArguments *string `json:"uriArguments,omitempty" tf:"uri_arguments,omitempty"`
}

type HTTPRequestURIRewriteParameters struct {

	// +kubebuilder:validation:Required
	URI *string `json:"uri" tf:"uri,omitempty"`

	// +kubebuilder:validation:Optional
	URIArguments *string `json:"uriArguments,omitempty" tf:"uri_arguments,omitempty"`
}

type HTTPRequestVersionObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type HTTPRequestVersionParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type HTTPResponseHeaderDeleteObservation struct {
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`
}

type HTTPResponseHeaderDeleteParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`
}

type HTTPResponseHeaderObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`
}

type HTTPResponseHeaderParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`
}

type HTTPResponseHeaderRewriteObservation struct {
	HeaderName *string `json:"headerName,omitempty" tf:"header_name,omitempty"`

	HeaderValue *string `json:"headerValue,omitempty" tf:"header_value,omitempty"`
}

type HTTPResponseHeaderRewriteParameters struct {

	// +kubebuilder:validation:Required
	HeaderName *string `json:"headerName" tf:"header_name,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`
}

type HTTPSSLObservation struct {
	ClientCertificateIssuerDn []ClientCertificateIssuerDnObservation `json:"clientCertificateIssuerDn,omitempty" tf:"client_certificate_issuer_dn,omitempty"`

	ClientCertificateSubjectDn []ClientCertificateSubjectDnObservation `json:"clientCertificateSubjectDn,omitempty" tf:"client_certificate_subject_dn,omitempty"`

	// Supported SSL ciphers
	ClientSupportedSSLCiphers []*string `json:"clientSupportedSslCiphers,omitempty" tf:"client_supported_ssl_ciphers,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	SessionReused *string `json:"sessionReused,omitempty" tf:"session_reused,omitempty"`

	UsedProtocol *string `json:"usedProtocol,omitempty" tf:"used_protocol,omitempty"`

	UsedSSLCipher *string `json:"usedSslCipher,omitempty" tf:"used_ssl_cipher,omitempty"`
}

type HTTPSSLParameters struct {

	// +kubebuilder:validation:Optional
	ClientCertificateIssuerDn []ClientCertificateIssuerDnParameters `json:"clientCertificateIssuerDn,omitempty" tf:"client_certificate_issuer_dn,omitempty"`

	// +kubebuilder:validation:Optional
	ClientCertificateSubjectDn []ClientCertificateSubjectDnParameters `json:"clientCertificateSubjectDn,omitempty" tf:"client_certificate_subject_dn,omitempty"`

	// Supported SSL ciphers
	// +kubebuilder:validation:Optional
	ClientSupportedSSLCiphers []*string `json:"clientSupportedSslCiphers,omitempty" tf:"client_supported_ssl_ciphers,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Optional
	SessionReused *string `json:"sessionReused,omitempty" tf:"session_reused,omitempty"`

	// +kubebuilder:validation:Optional
	UsedProtocol *string `json:"usedProtocol,omitempty" tf:"used_protocol,omitempty"`

	// +kubebuilder:validation:Optional
	UsedSSLCipher *string `json:"usedSslCipher,omitempty" tf:"used_ssl_cipher,omitempty"`
}

type IPHeaderObservation struct {
	GroupPath *string `json:"groupPath,omitempty" tf:"group_path,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	SourceAddress *string `json:"sourceAddress,omitempty" tf:"source_address,omitempty"`
}

type IPHeaderParameters struct {

	// +kubebuilder:validation:Optional
	GroupPath *string `json:"groupPath,omitempty" tf:"group_path,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Optional
	SourceAddress *string `json:"sourceAddress,omitempty" tf:"source_address,omitempty"`
}

type JwtAuthObservation struct {
	Key []KeyObservation `json:"key,omitempty" tf:"key,omitempty"`

	PassJwtToPool *bool `json:"passJwtToPool,omitempty" tf:"pass_jwt_to_pool,omitempty"`

	Realm *string `json:"realm,omitempty" tf:"realm,omitempty"`

	// JWT tokens
	Tokens []*string `json:"tokens,omitempty" tf:"tokens,omitempty"`
}

type JwtAuthParameters struct {

	// +kubebuilder:validation:Optional
	Key []KeyParameters `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	PassJwtToPool *bool `json:"passJwtToPool,omitempty" tf:"pass_jwt_to_pool,omitempty"`

	// +kubebuilder:validation:Optional
	Realm *string `json:"realm,omitempty" tf:"realm,omitempty"`

	// JWT tokens
	// +kubebuilder:validation:Optional
	Tokens []*string `json:"tokens,omitempty" tf:"tokens,omitempty"`
}

type KeyObservation struct {
	CertificatePath *string `json:"certificatePath,omitempty" tf:"certificate_path,omitempty"`

	PublicKeyContent *string `json:"publicKeyContent,omitempty" tf:"public_key_content,omitempty"`

	SymmetricKey *string `json:"symmetricKey,omitempty" tf:"symmetric_key,omitempty"`
}

type KeyParameters struct {

	// +kubebuilder:validation:Optional
	CertificatePath *string `json:"certificatePath,omitempty" tf:"certificate_path,omitempty"`

	// +kubebuilder:validation:Optional
	PublicKeyContent *string `json:"publicKeyContent,omitempty" tf:"public_key_content,omitempty"`

	// +kubebuilder:validation:Optional
	SymmetricKey *string `json:"symmetricKey,omitempty" tf:"symmetric_key,omitempty"`
}

type PolicyLbVirtualServerObservation struct {

	// IP access list control for filtering the connections from clients
	AccessListControl []AccessListControlObservation `json:"accessListControl,omitempty" tf:"access_list_control,omitempty"`

	// If enabled, all connections/requests sent to virtual server are logged to the access log file
	AccessLogEnabled *bool `json:"accessLogEnabled,omitempty" tf:"access_log_enabled,omitempty"`

	// Application profile for this virtual server
	ApplicationProfilePath *string `json:"applicationProfilePath,omitempty" tf:"application_profile_path,omitempty"`

	// This setting is used when load balancer terminates client SSL connection
	ClientSSL []ClientSSLObservation `json:"clientSsl,omitempty" tf:"client_ssl,omitempty"`

	// Default pool member ports when member port is not defined
	DefaultPoolMemberPorts []*string `json:"defaultPoolMemberPorts,omitempty" tf:"default_pool_member_ports,omitempty"`

	// Description for this resource
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Flag to enable Virtual Server
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Virtual Server IP address
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Flag to log significant events in access log, if access log is enabed
	LogSignificantEventOnly *bool `json:"logSignificantEventOnly,omitempty" tf:"log_significant_event_only,omitempty"`

	// To ensure one virtual server does not over consume resources, connections to a virtual server can be capped.
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// To ensure one virtual server does not over consume resources, connections to a member can be rate limited.
	MaxNewConnectionRate *float64 `json:"maxNewConnectionRate,omitempty" tf:"max_new_connection_rate,omitempty"`

	// NSX ID for this resource
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// Policy path for this resource
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// Path to persistence profile allowing related client connections to be sent to the same backend server.
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	// Path for Load Balancer Pool
	PoolPath *string `json:"poolPath,omitempty" tf:"pool_path,omitempty"`

	// Virtual Server ports
	Ports []*string `json:"ports,omitempty" tf:"ports,omitempty"`

	// The _revision property describes the current revision of the resource. To prevent clients from overwriting each other's changes, PUT operations must include the current _revision of the resource, which clients should obtain by issuing a GET operation. If the _revision provided in a PUT request is missing or stale, the operation will be rejected
	Revision *float64 `json:"revision,omitempty" tf:"revision,omitempty"`

	// List of load balancer rules for layer 7 virtual servers with LBHttpProfile
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`

	// This setting is used when load balancer establishes connection to the backend server
	ServerSSL []ServerSSLObservation `json:"serverSsl,omitempty" tf:"server_ssl,omitempty"`

	// Virtual Server can be associated with Load Balancer Service
	ServicePath *string `json:"servicePath,omitempty" tf:"service_path,omitempty"`

	// When load balancer can not select server in default pool or pool in rules, the request would be served by sorry pool
	SorryPoolPath *string `json:"sorryPoolPath,omitempty" tf:"sorry_pool_path,omitempty"`

	// Set of opaque identifiers meaningful to the user
	Tag []PolicyLbVirtualServerTagObservation `json:"tag,omitempty" tf:"tag,omitempty"`
}

type PolicyLbVirtualServerParameters struct {

	// IP access list control for filtering the connections from clients
	// +kubebuilder:validation:Optional
	AccessListControl []AccessListControlParameters `json:"accessListControl,omitempty" tf:"access_list_control,omitempty"`

	// If enabled, all connections/requests sent to virtual server are logged to the access log file
	// +kubebuilder:validation:Optional
	AccessLogEnabled *bool `json:"accessLogEnabled,omitempty" tf:"access_log_enabled,omitempty"`

	// Application profile for this virtual server
	// +kubebuilder:validation:Optional
	ApplicationProfilePath *string `json:"applicationProfilePath,omitempty" tf:"application_profile_path,omitempty"`

	// This setting is used when load balancer terminates client SSL connection
	// +kubebuilder:validation:Optional
	ClientSSL []ClientSSLParameters `json:"clientSsl,omitempty" tf:"client_ssl,omitempty"`

	// Default pool member ports when member port is not defined
	// +kubebuilder:validation:Optional
	DefaultPoolMemberPorts []*string `json:"defaultPoolMemberPorts,omitempty" tf:"default_pool_member_ports,omitempty"`

	// Description for this resource
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// Display name for this resource
	// +kubebuilder:validation:Optional
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Flag to enable Virtual Server
	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// Virtual Server IP address
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Flag to log significant events in access log, if access log is enabed
	// +kubebuilder:validation:Optional
	LogSignificantEventOnly *bool `json:"logSignificantEventOnly,omitempty" tf:"log_significant_event_only,omitempty"`

	// To ensure one virtual server does not over consume resources, connections to a virtual server can be capped.
	// +kubebuilder:validation:Optional
	MaxConcurrentConnections *float64 `json:"maxConcurrentConnections,omitempty" tf:"max_concurrent_connections,omitempty"`

	// To ensure one virtual server does not over consume resources, connections to a member can be rate limited.
	// +kubebuilder:validation:Optional
	MaxNewConnectionRate *float64 `json:"maxNewConnectionRate,omitempty" tf:"max_new_connection_rate,omitempty"`

	// NSX ID for this resource
	// +kubebuilder:validation:Optional
	NsxID *string `json:"nsxId,omitempty" tf:"nsx_id,omitempty"`

	// Path to persistence profile allowing related client connections to be sent to the same backend server.
	// +kubebuilder:validation:Optional
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	// Path for Load Balancer Pool
	// +kubebuilder:validation:Optional
	PoolPath *string `json:"poolPath,omitempty" tf:"pool_path,omitempty"`

	// Virtual Server ports
	// +kubebuilder:validation:Optional
	Ports []*string `json:"ports,omitempty" tf:"ports,omitempty"`

	// List of load balancer rules for layer 7 virtual servers with LBHttpProfile
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// This setting is used when load balancer establishes connection to the backend server
	// +kubebuilder:validation:Optional
	ServerSSL []ServerSSLParameters `json:"serverSsl,omitempty" tf:"server_ssl,omitempty"`

	// Virtual Server can be associated with Load Balancer Service
	// +kubebuilder:validation:Optional
	ServicePath *string `json:"servicePath,omitempty" tf:"service_path,omitempty"`

	// When load balancer can not select server in default pool or pool in rules, the request would be served by sorry pool
	// +kubebuilder:validation:Optional
	SorryPoolPath *string `json:"sorryPoolPath,omitempty" tf:"sorry_pool_path,omitempty"`

	// Set of opaque identifiers meaningful to the user
	// +kubebuilder:validation:Optional
	Tag []PolicyLbVirtualServerTagParameters `json:"tag,omitempty" tf:"tag,omitempty"`
}

type PolicyLbVirtualServerTagObservation struct {
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type PolicyLbVirtualServerTagParameters struct {

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	Tag *string `json:"tag,omitempty" tf:"tag,omitempty"`
}

type RuleObservation struct {

	// A list of actions to be executed at specified phase when load balancer rule matches.
	Action []ActionObservation `json:"action,omitempty" tf:"action,omitempty"`

	// A list of match conditions used to match application traffic.
	Condition []ConditionObservation `json:"condition,omitempty" tf:"condition,omitempty"`

	// Display name for this resource
	DisplayName *string `json:"displayName,omitempty" tf:"display_name,omitempty"`

	// Match strategy for determining match of multiple conditions (ALL or ANY, default: ANY).
	MatchStrategy *string `json:"matchStrategy,omitempty" tf:"match_strategy,omitempty"`

	// Load balancer processing phase, one of HTTP_REQUEST_REWRITE, HTTP_FORWARDING (Default), HTTP_RESPONSE_REWRITE, HTTP_ACCESS, TRANSPORT.
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`
}

type RuleParameters struct {

	// A list of actions to be executed at specified phase when load balancer rule matches.
	// +kubebuilder:validation:Required
	Action []ActionParameters `json:"action" tf:"action,omitempty"`

	// A list of match conditions used to match application traffic.
	// +kubebuilder:validation:Optional
	Condition []ConditionParameters `json:"condition,omitempty" tf:"condition,omitempty"`

	// Display name for this resource
	// +kubebuilder:validation:Required
	DisplayName *string `json:"displayName" tf:"display_name,omitempty"`

	// Match strategy for determining match of multiple conditions (ALL or ANY, default: ANY).
	// +kubebuilder:validation:Optional
	MatchStrategy *string `json:"matchStrategy,omitempty" tf:"match_strategy,omitempty"`

	// Load balancer processing phase, one of HTTP_REQUEST_REWRITE, HTTP_FORWARDING (Default), HTTP_RESPONSE_REWRITE, HTTP_ACCESS, TRANSPORT.
	// +kubebuilder:validation:Optional
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`
}

type SSLModeSelectionObservation struct {
	SSLMode *string `json:"sslMode,omitempty" tf:"ssl_mode,omitempty"`
}

type SSLModeSelectionParameters struct {

	// +kubebuilder:validation:Required
	SSLMode *string `json:"sslMode" tf:"ssl_mode,omitempty"`
}

type SSLSniObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	Sni *string `json:"sni,omitempty" tf:"sni,omitempty"`
}

type SSLSniParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	Sni *string `json:"sni" tf:"sni,omitempty"`
}

type SelectPoolObservation struct {
	PoolID *string `json:"poolId,omitempty" tf:"pool_id,omitempty"`
}

type SelectPoolParameters struct {

	// +kubebuilder:validation:Required
	PoolID *string `json:"poolId" tf:"pool_id,omitempty"`
}

type ServerSSLObservation struct {

	// If server auth type is REQUIRED, server certificate must be signed by one Certificate Authorities
	CAPaths []*string `json:"caPaths,omitempty" tf:"ca_paths,omitempty"`

	// Certificate chain depth
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client certificat path for client authentication
	ClientCertificatePath *string `json:"clientCertificatePath,omitempty" tf:"client_certificate_path,omitempty"`

	// Certificate Revocation Lists can be specified disallow compromised certificates
	CrlPaths []*string `json:"crlPaths,omitempty" tf:"crl_paths,omitempty"`

	// Server SSL Profile Path
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// Server authentication mode
	ServerAuth *string `json:"serverAuth,omitempty" tf:"server_auth,omitempty"`
}

type ServerSSLParameters struct {

	// If server auth type is REQUIRED, server certificate must be signed by one Certificate Authorities
	// +kubebuilder:validation:Optional
	CAPaths []*string `json:"caPaths,omitempty" tf:"ca_paths,omitempty"`

	// Certificate chain depth
	// +kubebuilder:validation:Optional
	CertificateChainDepth *float64 `json:"certificateChainDepth,omitempty" tf:"certificate_chain_depth,omitempty"`

	// Client certificat path for client authentication
	// +kubebuilder:validation:Optional
	ClientCertificatePath *string `json:"clientCertificatePath,omitempty" tf:"client_certificate_path,omitempty"`

	// Certificate Revocation Lists can be specified disallow compromised certificates
	// +kubebuilder:validation:Optional
	CrlPaths []*string `json:"crlPaths,omitempty" tf:"crl_paths,omitempty"`

	// Server SSL Profile Path
	// +kubebuilder:validation:Optional
	SSLProfilePath *string `json:"sslProfilePath,omitempty" tf:"ssl_profile_path,omitempty"`

	// Server authentication mode
	// +kubebuilder:validation:Optional
	ServerAuth *string `json:"serverAuth,omitempty" tf:"server_auth,omitempty"`
}

type TCPHeaderObservation struct {

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	SourcePort *string `json:"sourcePort,omitempty" tf:"source_port,omitempty"`
}

type TCPHeaderParameters struct {

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// +kubebuilder:validation:Required
	SourcePort *string `json:"sourcePort" tf:"source_port,omitempty"`
}

type VariableAssignmentObservation struct {
	VariableName *string `json:"variableName,omitempty" tf:"variable_name,omitempty"`

	VariableValue *string `json:"variableValue,omitempty" tf:"variable_value,omitempty"`
}

type VariableAssignmentParameters struct {

	// +kubebuilder:validation:Required
	VariableName *string `json:"variableName" tf:"variable_name,omitempty"`

	// +kubebuilder:validation:Required
	VariableValue *string `json:"variableValue" tf:"variable_value,omitempty"`
}

type VariableObservation struct {

	// If true, case is significant in condition matching
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	MatchType *string `json:"matchType,omitempty" tf:"match_type,omitempty"`

	VariableName *string `json:"variableName,omitempty" tf:"variable_name,omitempty"`

	VariableValue *string `json:"variableValue,omitempty" tf:"variable_value,omitempty"`
}

type VariableParameters struct {

	// If true, case is significant in condition matching
	// +kubebuilder:validation:Optional
	CaseSensitive *bool `json:"caseSensitive,omitempty" tf:"case_sensitive,omitempty"`

	// Whether to reverse match result of this condition
	// +kubebuilder:validation:Optional
	Inverse *bool `json:"inverse,omitempty" tf:"inverse,omitempty"`

	// Match type (STARTS_WITH, ENDS_WITH, EQUALS, CONTAINS, REGEX)
	// +kubebuilder:validation:Required
	MatchType *string `json:"matchType" tf:"match_type,omitempty"`

	// +kubebuilder:validation:Required
	VariableName *string `json:"variableName" tf:"variable_name,omitempty"`

	// +kubebuilder:validation:Required
	VariableValue *string `json:"variableValue" tf:"variable_value,omitempty"`
}

type VariablePersistenceLearnObservation struct {
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	VariableHashEnabled *bool `json:"variableHashEnabled,omitempty" tf:"variable_hash_enabled,omitempty"`

	VariableName *string `json:"variableName,omitempty" tf:"variable_name,omitempty"`
}

type VariablePersistenceLearnParameters struct {

	// +kubebuilder:validation:Optional
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	// +kubebuilder:validation:Optional
	VariableHashEnabled *bool `json:"variableHashEnabled,omitempty" tf:"variable_hash_enabled,omitempty"`

	// +kubebuilder:validation:Required
	VariableName *string `json:"variableName" tf:"variable_name,omitempty"`
}

type VariablePersistenceOnObservation struct {
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	VariableHashEnabled *bool `json:"variableHashEnabled,omitempty" tf:"variable_hash_enabled,omitempty"`

	VariableName *string `json:"variableName,omitempty" tf:"variable_name,omitempty"`
}

type VariablePersistenceOnParameters struct {

	// +kubebuilder:validation:Optional
	PersistenceProfilePath *string `json:"persistenceProfilePath,omitempty" tf:"persistence_profile_path,omitempty"`

	// +kubebuilder:validation:Optional
	VariableHashEnabled *bool `json:"variableHashEnabled,omitempty" tf:"variable_hash_enabled,omitempty"`

	// +kubebuilder:validation:Required
	VariableName *string `json:"variableName" tf:"variable_name,omitempty"`
}

// PolicyLbVirtualServerSpec defines the desired state of PolicyLbVirtualServer
type PolicyLbVirtualServerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PolicyLbVirtualServerParameters `json:"forProvider"`
}

// PolicyLbVirtualServerStatus defines the observed state of PolicyLbVirtualServer.
type PolicyLbVirtualServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PolicyLbVirtualServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbVirtualServer is the Schema for the PolicyLbVirtualServers API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,nsxt}
type PolicyLbVirtualServer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.applicationProfilePath)",message="applicationProfilePath is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.displayName)",message="displayName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ipAddress)",message="ipAddress is a required parameter"
	// +kubebuilder:validation:XValidation:rule="self.managementPolicy == 'ObserveOnly' || has(self.forProvider.ports)",message="ports is a required parameter"
	Spec   PolicyLbVirtualServerSpec   `json:"spec"`
	Status PolicyLbVirtualServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PolicyLbVirtualServerList contains a list of PolicyLbVirtualServers
type PolicyLbVirtualServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []PolicyLbVirtualServer `json:"items"`
}

// Repository type metadata.
var (
	PolicyLbVirtualServer_Kind             = "PolicyLbVirtualServer"
	PolicyLbVirtualServer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: PolicyLbVirtualServer_Kind}.String()
	PolicyLbVirtualServer_KindAPIVersion   = PolicyLbVirtualServer_Kind + "." + CRDGroupVersion.String()
	PolicyLbVirtualServer_GroupVersionKind = CRDGroupVersion.WithKind(PolicyLbVirtualServer_Kind)
)

func init() {
	SchemeBuilder.Register(&PolicyLbVirtualServer{}, &PolicyLbVirtualServerList{})
}
